<!doctype html>
<html lang="en">
<meta charset="UTF-8">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">

    <script src="https://unpkg.com/kotlin-playground@1"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { KotlinPlayground('.code-blocks-selector'); });</script>

    <title>aoc2021 by Omar Miatello</title>
</head>
<body>
<main class="container">
    <h1>Advent of Code 2021 - by Omar Miatello</h1>
    <p>
        Read only: <a href="https://github.com/omarmiatello/aoc-2021-in-kotlin/tree/main/src">https://github.com/omarmiatello/aoc-2021-in-kotlin/tree/main/src</a><br />
        Editable in Kotlin Playground: <a href="https://omarmiatello.github.io/aoc-2021-in-kotlin">https://omarmiatello.github.io/aoc-2021-in-kotlin</a>
    </p>

    <p>Click â–¶ Run to show the result</p>

<h2 id="day23"><a href="#day23">Day 23</a> (<a href="https://adventofcode.com/2021/day/23">story</a>)</h2>
<code class="code-blocks-selector">
import kotlin.time.ExperimentalTime
import kotlin.time.measureTimedValue

//sampleStart
import kotlin.math.absoluteValue

// https://adventofcode.com/2021/day/23
object Day23 : AdventOfCode, Solution by Omar_Miatello(
    day = 23,
    parser = { lines -&gt;
        Location(
            rooms = (0..3).map {
                Room(
                    state = &quot;${lines[2][3 + it * 2]}${lines[3][3 + it * 2]}&quot;,
                    expectedAmphipod = energyMap.toList()[it].first,
                )
            }
        )
    },
    part1 = { input -&gt;
        input.leastEnergyRequired(100)
    },
    testsPart1 = result(12521),
    part2 = { input -&gt;
        val added = listOf(&quot;DD&quot;, &quot;CB&quot;, &quot;BA&quot;, &quot;AC&quot;)
        input.copy(
            rooms = input.rooms
                .mapIndexed { i, room -&gt; room.copy(state = &quot;${room.state[0]}${added[i]}${room.state[1]}&quot;) },
            hallway = input.hallway.copy(maxConcurrent = 7),
        ).leastEnergyRequired(100)
    },
    //testsPart2 = result(44169),
    testsPart2 = results(), // 48057
)

private fun Location.leastEnergyRequired(maxBeforeStop: Int): Int {
    val potentialResults = mutableListOf&lt;Location&gt;()
    val locations = mutableListOf(this)
    while (potentialResults.size &lt; maxBeforeStop) {
        locations.addAll(locations.removeAt(0).allMoves())
        locations.sort()
        locations.firstOrNull { it.isCompleted() }?.also { potentialResults.add(it) }
    }
    return potentialResults.minOf { it.energyConsumed }
}

private val energyMap = mapOf('A' to 1, 'B' to 10, 'C' to 100, 'D' to 1000)
private fun Char.energyTo(steps: Int) = energyMap.getValue(this) * steps
private fun Char.toRoomId() = energyMap.toList().indexOfFirst { this == it.first }

private data class Hallway(val state: String = &quot;..0.1.2.3..&quot;, val maxConcurrent: Int = 3) {
    fun canMoveIn() = state.count { it.isLetter() } &lt; maxConcurrent
    fun roomPosition(room: Int) = 2 + room * 2

    fun energyFor(p1: Int, p2: Int, c: Char = state[p1], fromRoom: Boolean): Int? {
        val start = kotlin.math.min(p1, p2)
        val end = kotlin.math.max(p1, p2)
        return if (c.isLetter() && state.substring(start..end).count { it.isLetter() } == if (fromRoom) 0 else 1) {
            c.energyTo(end - start)
        } else null
    }

    override fun toString() = state
}

private data class Room(
    val state: String,
    private val expectedAmphipod: Char,
) {
    private val validGuests = listOf('.', expectedAmphipod)
    fun completedPercent() = state.takeLastWhile { it == expectedAmphipod }.count().toDouble() / state.count()
    fun canMoveOut() = state.any { it !in validGuests }
    fun canMoveIn() = state.all { it in validGuests }
}

private data class Location(
    val rooms: List&lt;Room&gt;,
    val hallway: Hallway = Hallway(),
    val energyConsumed: Int = 0,
) : Comparable&lt;Location&gt; {
    fun isCompleted() = rooms.all { it.completedPercent() == 1.0 }
    fun allMoves(): List&lt;Location&gt; = (allMovesToRooms() + allMovesToHallway()).sorted()
    fun allMovesToHallway() = rooms.indices.flatMap { allMovesToHallwayFromRoom(it) }
    fun allMovesToHallwayFromRoom(roomId: Int) = hallway.state.indices.mapNotNull { moveRoomToHallway(roomId, it) }
    fun allMovesToRooms() = hallway.state.indices.mapNotNull { moveHallwayToRoom(it) }

    fun moveRoomToHallway(
        roomId: Int,
        end: Int,
    ): Location? {
        val room = rooms[roomId]
        return if (room.canMoveOut() && hallway.canMoveIn()) {
            val (iRoom, c) = room.state.withIndex().first { it.value.isLetter() }
            val roomEnergy = c.energyTo(iRoom + 1)
            val start = hallway.roomPosition(roomId)
            if (hallway.state[end] == '.') {
                val hallwayEnergy = hallway.energyFor(start, end, c, fromRoom = true)
                if (hallwayEnergy != null) {
                    Location(
                        rooms = rooms.mapIndexed { i, oldRoom -&gt;
                            if (i == roomId) {
                                room.copy(state = room.state.replaceRange(iRoom..iRoom, &quot;.&quot;))
                            } else oldRoom
                        },
                        hallway = hallway.copy(state = hallway.state.replaceRange(end..end, &quot;$c&quot;)),
                        energyConsumed = energyConsumed + roomEnergy + hallwayEnergy,
                    )
                } else null
            } else null
        } else null
    }

    fun moveHallwayToRoom(start: Int): Location? {
        val c = hallway.state[start]
        return if (c.isLetter()) {
            val end = hallway.roomPosition(c.toRoomId())
            val hallwayEnergy = hallway.energyFor(start, end, c, fromRoom = false)
            if (hallwayEnergy != null) {
                val roomId = c.toRoomId()
                if (rooms[roomId].canMoveIn()) {
                    val room = rooms[roomId]
                    val iRoom = room.state.lastIndexOf('.')
                    val roomEnergy = c.energyTo(iRoom + 1)
                    Location(
                        rooms = rooms.mapIndexed { i, oldRoom -&gt;
                            if (i == roomId) {
                                room.copy(state = room.state.replaceRange(iRoom..iRoom, &quot;$c&quot;))
                            } else oldRoom
                        },
                        hallway = hallway.copy(state = hallway.state.replaceRange(start..start, &quot;.&quot;)),
                        energyConsumed = energyConsumed + roomEnergy + hallwayEnergy,
                    )
                } else null
            } else null
        } else null
    }

    override fun compareTo(other: Location) = compareValuesBy(this, other) {
        fun Char.energyToExit(start: Int) = energyTo(start + 1)

        fun Char.energyToHallway(start: Int, newRoomId: Int) =
            energyTo((start - it.hallway.roomPosition(newRoomId)).absoluteValue)

        fun Char.energyToEnter(newRoomId: Int): Int {
            val newRoom = it.rooms[newRoomId]
            val enter = newRoom.state.indexOfLast { it == '.' } + 1
            return energyTo(if (newRoom.canMoveIn()) {
                enter
            } else {
                enter + newRoom.state.withIndex()
                    .sumOf { (i, it) -&gt; if (it.isLetter()) it.energyTo(i + 2) else 0 }
            })
        }

        val energyForRooms = it.rooms.withIndex().sumOf { (roomId, room) -&gt;
            room.state.withIndex().sumOf { (cId, c) -&gt;
                val newRoomId = c.toRoomId()
                if (c.isLetter() && roomId != newRoomId) {
                    val energyToHallway = c.energyToHallway(it.hallway.roomPosition(roomId), newRoomId)
                    c.energyToExit(cId) + energyToHallway + c.energyToEnter(newRoomId)
                } else 0
            }
        }
        val energyForHallways = it.hallway.state.withIndex().sumOf { (start, c) -&gt;
            if (c.isLetter()) {
                c.energyToHallway(start, c.toRoomId()) + c.energyToEnter(c.toRoomId())
            } else 0
        }
        energyForRooms + energyForHallways
    }

    override fun toString() = &quot;$hallway (energy: $energyConsumed)\n&quot; +
            rooms.first().state.indices.joinToString(&quot;\n&quot;) { n -&gt;
                &quot;  ${rooms.joinToString(&quot; &quot;) { it.state[n].toString() }}&quot;
            }
}
//sampleEnd

fun main() {
    Day23.launch()
}

sealed interface AdventOfCode

fun interface Solution { fun launch() }

fun &lt;PARSED, RES1, RES2&gt; Omar_Miatello(
    day: Int,
    parser: (List&lt;String&gt;) -&gt; PARSED,
    part1: (PARSED) -&gt; RES1,
    testsPart1: (Int) -&gt; List&lt;Pair&lt;List&lt;String&gt;, RES1&gt;&gt;,
    part2: (PARSED) -&gt; RES2,
    testsPart2: (Int) -&gt; List&lt;Pair&lt;List&lt;String&gt;, RES2&gt;&gt;,
) = Solution {
    fun &lt;RES&gt; on(
        expected: RES? = null,
        block: () -&gt; RES,
    ) {
        val input = if (expected != null) inputTest else inputDay
        val (output, duration) = measureTimedValue { block() }
        val millis = duration.inWholeMilliseconds
        if (expected != null) {
            check(output == expected) { &quot;[$millis ms] Something goes wrong! expected: $expected | current: $output&quot; }
        } else {
            println(&quot;[${millis}ms]\t$output&quot;)
        }
    }

    println(&quot;Day $day&quot;)
    val parserDay = parser(inputDay)
    testsPart1(day).forEach { (inputTest, expectedTest) -> on(expected = expectedTest) { part1(parser(inputTest)) } }
    on { part1(parserDay) }
    testsPart2(day).forEach { (inputTest, expectedTest) -> on(expected = expectedTest) { part2(parser(inputTest)) } }
    on { part2(parserDay) }
}

fun &lt;RES&gt; result(expected: RES): (Int) -&gt; List&lt;Pair&lt;List&lt;String&gt;, RES&gt;&gt; = { day: Int -&gt;
    listOf(inputTest to expected)
}

fun &lt;RES&gt; results(vararg inputToRes: Pair&lt;List&lt;String&gt;, RES&gt;): (Int) -&gt; List&lt;Pair&lt;List&lt;String&gt;, RES&gt;&gt; = { inputToRes.toList() }

val inputTest = &quot;&quot;&quot;#############
#...........#
###B#C#B#D###
  #A#D#C#A#
  #########&quot;&quot;&quot;.lines()

val inputDay = &quot;&quot;&quot;#############
#...........#
###D#A#C#A###
  #D#C#B#B#
  #########&quot;&quot;&quot;.lines()
</code>

</main>
</body>
</html>